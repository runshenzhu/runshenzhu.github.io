<!doctype html>
<html class="theme-next use-motion theme-next-next">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>




  <link rel="stylesheet" type="text/css" href="/tags/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/tags/css/main.css?v=0.4.0"/>


    <meta name="description" content="excited!!!" />



	<meta name="keywords" content="C/C++,reading," />

  <title> Reading Notes for Effective C++ //  </title>
</head>

<body>
  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/tags/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title"></span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          Home
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          Archives
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          Tags
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
            
          

          <div id="posts" class="posts-expand">
            
  

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              Reading Notes for Effective C++
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            Posted on 2014-10-01
          
        </span>

        
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/tags/2014/10/01/2014-10-01-Study Notes for <<Effective C++>>/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/01/2014-10-01-Study Notes for <<Effective C++>>/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          <p><strong>When I reading <em>Effective C++</em>, I took the following notes, most of which are just exactly the same words, same sentences as the book’s. This page is used as a reference, reminding me of some important concepts and skills</strong><br><a id="more"></a></p>
<ul>
<li>Item 0<br>explicit prevents constructors from being used to perform implicit type conversions.</li>
</ul>
<ul>
<li><p>Item 1: View C++ as a federation of languages<br>We should view C++ not as a single language but as a federation of related languages.</p>
<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>The STL</li>
</ul>
</li>
<li><p>Item 2: Prefer consts, enums, and inlines to #defines<br></p>
<ul>
<li>#define enum 不会分配地址空间<br></li>
<li>const 看编译器，(或者在引用的时候分配)<br></li>
<li>class中，为declaration<br></li>
<li>#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))    易错<br>用 template + inline 代替</li>
</ul>
</li>
</ul>
<ul>
<li><p>Item 3: Use const whenever possible<br></p>
<ul>
<li><p>If the word const appears to the left of the asterisk, what’s pointed to is constant;<br>if the word const appears to the right of the asterisk, the pointer itself is constant;<br>if const appears on both sides, both are constant.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting;	<span class="comment">// non-const pointer,</span></span><br><span class="line">				<span class="comment">// const data</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;	<span class="comment">// const pointer,</span></span><br><span class="line">		    		<span class="comment">// non-const data</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>some programmers list const before the type.<br>Others list it after the type but before the asterisk.<br>There is no difference in meaning</p>
</li>
<li><p>迭代器部分还要看</p>
</li>
<li><p>const function</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">(a * b) = c;    <span class="comment">//assignment or comparsion</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Item 4: Make sure that objects are initialized before they’re used</p>
<ul>
<li><p>not to confuse assignment with initialization</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> std::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> std::<span class="built_in">string</span>&amp; address,</span><br><span class="line">                 <span class="keyword">const</span> std::<span class="stl_container"><span class="built_in">list</span>&lt;PhoneNumber&gt;</span>&amp; phones)</span><br><span class="line">: theName(name),</span><br><span class="line">  theAddress(address),          <span class="comment">// these are now all initializations</span></span><br><span class="line">  thePhones(phones),</span><br><span class="line">  numTimesConsulted(<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>The assignment-based version first called default constructors to initialize theName, theAddress, and thePhones, then promptly assigned new values on top of the default-constructed ones. </p>
</li>
<li>always list members in the initialization list in the same order as they’re declared in the class</li>
</ul>
</li>
</ul>
<ul>
<li>Item 5: Know what functions C++ silently writes and calls</li>
<li><p>Item 6: Explicitly disallow the use of compiler-generated functions you do not want</p>
<ul>
<li>declare the copy constructor and the copy assignment operator private and not to define them，you keep people from calling it.</li>
</ul>
</li>
<li><p>Item 7: Declare destructors virtual in polymorphic base classes</p>
<ul>
<li>Polymorphic base classes should declare virtual destructors. If a class has any virtual functions, it should have a virtual destructor.</li>
<li>Classes not designed to be base classes or not designed to be used polymorphically should not declare virtual destructors.</li>
</ul>
</li>
</ul>
<ul>
<li><p>Item 8: Prevent exceptions from leaving destructors</p>
<ul>
<li>Destructors should never emit exceptions. If functions called in a destructor may throw, the destructor should catch any exceptions, then swallow them or terminate the program.</li>
<li>If class clients need to be able to react to exceptions thrown during an operation, the class should provide a regular (i.e., non-destructor) function that performs the operation.</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Item 13: Use objects to manage resources</strong></p>
<ul>
<li><p>The standard library’s <strong>auto_ptr</strong> is tailor-made for helping manage resources. auto_ptr is a pointer-like object (a smart pointer) whose destructor automatically calls delete on what it points to.</p>
</li>
<li><p>It’s important that there never be more than one auto_ptr pointing to an object, and auto_ptrs have an unusual characteristic: copying them (via copy constructor or copy assignment operator) sets them to null, and the copying pointer assumes sole ownership of the resource!</p>
</li>
<li><p>An alternative to auto_ptr is a reference-counting smart pointer (RCSP), which keeps track of how many objects point to a particular resource and automatically deletes the resource when nobody is pointing to it any longer. however, RCSPs can’t break cycles of references.</p>
</li>
<li><p>These tricks are so-called Resource Acquisition Is Initialization (RAII)</p>
</li>
</ul>
</li>
<li><p>Item 14: Think carefully about copying behavior in resource-managing classes.</p>
</li>
<li><p>Item 15: Provide access to raw resources in resource-managing classes.</p>
<ul>
<li>tr1::shared_ptr and auto_ptr both offer a get member function to perform an explicit conversion, i.e., to return (a copy of) the raw pointer inside the smart pointer object.</li>
</ul>
</li>
</ul>
<ul>
<li><p>Item 17: Store newed objects in smart pointers in standalone statements</p>
<ul>
<li>C++ compilers are granted considerable latitude in determining the order in which these things are to be done. </li>
</ul>
</li>
<li><p>Item 18: Make interfaces easy to use correctly and hard to use incorrectly</p>
</li>
</ul>
<ul>
<li><p>Item 20: Prefer pass-by-reference-to-const to pass-by-value</p>
<ul>
<li><p>This is much more efficient: no constructors or destructors are called, because no new objects are being created. </p>
</li>
<li><p>Passing parameters by reference also avoids the slicing problem. </p>
</li>
<li><p>However, if you have an object of a built-in type (e.g., an int), it’s often more efficient to pass it by value than by reference. For built-in types, then, when you have a choice between pass-by-value and pass-by-reference-to-const, it’s not unreasonable to choose pass-by-value. This same advice applies to iterators and function objects in the STL, because, by convention, they are designed to be passed by value.</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Item 21: Don’t try to return a reference when you must return an object</p>
<ul>
<li><p>some examples can elucidate this topic greatly</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span> *(<span class="keyword">const</span> Rational&amp; lhs,   <span class="comment">// warning! bad code!</span></span><br><span class="line">                          <span class="keyword">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad code</span></span><br><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span> *(<span class="keyword">const</span> Rational&amp; lhs,   <span class="comment">// warning! more bad</span></span><br><span class="line">                          <span class="keyword">const</span> Rational&amp; rhs)   <span class="comment">// code!</span></span><br><span class="line">&#123;</span><br><span class="line">  Rational  *result = <span class="keyword">new</span> Rational(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">  <span class="keyword">return</span>  *result;</span><br><span class="line">&#125;</span><br><span class="line">Rational w, x, y, z;</span><br><span class="line">w = x * y * z; <span class="comment">//resource leak</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//bad code</span><br><span class="line">const Rational&amp; operator *(const Rational&amp; lhs,    // warning! yet more</span><br><span class="line">                          const Rational&amp; rhs)    // bad code!</span><br><span class="line">&#123;</span><br><span class="line">  static Rational result;             // static object to which a</span><br><span class="line">                                      // reference will be returned</span><br><span class="line">  result = ... ;                      // multiply lhs by rhs and put the</span><br><span class="line">                                      // product inside result</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">if ((a * b) == (c * d))  &#123;</span><br><span class="line">    do whatever's appropriate when the products are equal;</span><br><span class="line">&#125; else    &#123;</span><br><span class="line">   //never get into here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reasonable code</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span> *(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> Rational(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Item 26: Postpone variable definitions as long as possible.</p>
<ul>
<li><p>Whenever you define a variable of a type with a constructor or destructor, you incur the cost of construction when control reaches the variable’s definition, and you incur the cost of destruction when the variable goes out of scope. </p>
</li>
<li><p>Not only should you postpone a variable’s definition until right before you have to use the variable, you should also try to postpone the definition until you have initialization arguments for it. By doing so, you avoid constructing and destructing unneeded objects, and you avoid unnecessary default constructions. </p>
</li>
</ul>
</li>
<li><p>Item 27: Minimize casting</p>
<ul>
<li><p>const_cast is typically used to cast away the constness of objects. It is the only C++-style cast that can do this.</p>
</li>
<li><p>dynamic_cast is primarily used to perform “safe downcasting,” i.e., to determine whether an object is of a particular type in an inheritance hierarchy. It is the only cast that cannot be performed using the old-style syntax. It is also the only cast that may have a significant runtime cost. (I’ll provide details on this a bit later.)</p>
</li>
<li><p>reinterpret_cast is intended for low-level casts that yield implementation-dependent (i.e., unportable) results, e.g., casting a pointer to an int. Such casts should be rare outside low-level code. I use it only once in this book, and that’s only when discussing how you might write a debugging allocator for raw memory.</p>
</li>
<li><p>static_cast can be used to force implicit conversions (e.g., non-const object to const object (as in Item 3), int to double, etc.). It can also be used to perform the reverse of many such conversions (e.g., void* pointers to typed pointers, pointer-to-base to pointer-to-derived), though it cannot cast from const to non-const objects. (Only const_cast can do that.)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Window &#123;                                <span class="comment">// base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123; ... &#125;             <span class="comment">// base onResize impl</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> SpecialWindow: <span class="keyword">public</span> Window &#123;          <span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;                   <span class="comment">// derived onResize impl;</span></span><br><span class="line">    <span class="keyword">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).onResize();    <span class="comment">// cast *this to Window,</span></span><br><span class="line">                                              <span class="comment">// then call its onResize;</span></span><br><span class="line">                                              <span class="comment">// this doesn't work!</span></span><br><span class="line">    ...                                       <span class="comment">// do SpecialWindow-</span></span><br><span class="line">  &#125;                                           <span class="comment">// specific stuff</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>the cast creates a new, temporary copy of the base class part of *this, then invokes onResize on the copy!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The solution is to eliminate the cast</span></span><br><span class="line"><span class="keyword">class</span> SpecialWindow: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Window::onResize();                    <span class="comment">// call Window::onResize</span></span><br><span class="line">    ...                                    <span class="comment">// on *this</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>many implementations of dynamic_cast can be quite slow.</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Item 30: Understand the ins and outs of inlining.</p>
<ul>
<li><p>Inline functions must typically be in header files, because most build environments do inlining during compilation.</p>
</li>
<li><p>Coupled with the fact that compilers typically don’t perform inlining across calls through function pointers, this means that calls to an inline function may or may not be inlined, depending on how the calls are made</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Item 33: Avoid hiding inherited names</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Derived: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>The scope-based name hiding rule hasn’t changed, so all functions named mf1 and mf3 in the base class are hidden by the functions named mf1 and mf3 in the derived class. From the perspective of name lookup, Base::mf1 and Base::mf3 are no longer inherited by Derived.</p>
</li>
<li><p>Unfortunately, you typically want to inherit the overloads.You do it with using declarations:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">	  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Derived: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Base::mf1;       <span class="comment">// make all things in Base named mf1 and mf3</span></span><br><span class="line">  <span class="keyword">using</span> Base::mf3;       <span class="comment">// visible (and public) in Derived's scope</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Item 34: Differentiate between inheritance of interface and inheritance of implementation</p>
<ul>
<li>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;	<span class="comment">//pure virtual function</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;  <span class="comment">//simple (impure?) virtual function</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//non-virtual function</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>The two most salient features of pure virtual functions are that they must be redeclared by any concrete class that inherits them, and they typically have no definition in abstract classes. Put these two characteristics together, and you realize that <strong>The purpose of declaring a pure virtual function is to have derived classes inherit a function interface only.</strong></p>
</li>
<li><p>it is possible to provide a definition for a pure virtual function. That is, you could provide an implementation for Shape::draw, and C++ wouldn’t complain, but the only way to call it would be to qualify the call with the class name:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Rectangle: <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br><span class="line">Shape *ps = <span class="keyword">new</span> Shape;              <span class="comment">// error! Shape is abstract</span></span><br><span class="line">Shape *ps1 = <span class="keyword">new</span> Rectangle;         <span class="comment">// fine</span></span><br><span class="line">ps1-&gt;draw();                     <span class="comment">// calls Rectangle::draw</span></span><br><span class="line">ps1-&gt;Shape::draw();                 <span class="comment">// calls Shape::draw</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>The purpose of declaring a simple virtual function is to have derived classes inherit a function interface as well as a default implementation.</p>
</li>
<li><p>Yet they still agree that interface and default implementation should be separated. How do they resolve this seeming contradiction? By taking advantage of the fact that pure virtual functions must be redeclared in concrete derived classes, but they may also have implementations of their own.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line"> 		...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Airplane::fly(<span class="keyword">const</span> Airport&amp; destination)     <span class="comment">// an implementation of</span></span><br><span class="line">&#123;                                                  <span class="comment">// a pure virtual function</span></span><br><span class="line"> 		<span class="keyword">default</span> code <span class="keyword">for</span> flying an airplane to</span><br><span class="line"> 		the given destination</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ModelA: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span><br><span class="line"> 	</span>&#123;   	Airplane::fly(destination); &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>however, you’ve lost the ability to give the two functions different protection levels: the code that used to be protected (by being in defaultFly) is now public (because it’s in fly).</p>
</li>
<li><p>The purpose of <strong>declaring a non-virtual function</strong> is to have derived classes inherit a function interface as well as a mandatory implementation.</p>
</li>
</ul>
</li>
<li><p>Item 35: Consider alternatives to virtual functions</p>
<ul>
<li>having clients call private virtual functions indirectly through public non-virtual member functions — is known as the non-virtual interface (NVI) idiom. </li>
<li>An advantage of the NVI idiom is suggested by the “do ‘before’ stuff” and “do ‘after’ stuff” comments in the code. (i.e before action/after action</li>
<li>function pointer </li>
<li><p>TR1::function </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::tr1::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br></pre></td></tr></table></figure>
</li>
<li><p>The “Classic” Strategy Pattern</p>
</li>
</ul>
</li>
<li><p>Item 36: Never redefine an inherited non-virtual function</p>
<ul>
<li>If you are writing class D and you redefine a non-virtual function mf that you inherit from class B, D objects will likely exhibit inconsistent behavior.<ul>
<li>Everything that applies to B objects also applies to D objects, because every D object is-a B object;</li>
<li>Classes derived from B must inherit both the interface and the implementation of mf, because mf is non-virtual in B.</li>
</ul>
</li>
<li>this also explains why destructors in polymorphic base classes should be virtual.</li>
</ul>
</li>
</ul>
<ul>
<li><p>Item 37: Never redefine a function’s inherited default parameter value</p>
<ul>
<li>virtual functions are dynamically bound, but default parameter values are statically bound.</li>
<li>One of the alternatives is the non-virtual interface idiom (NVI idiom): having a public non-virtual function in a base class call a private virtual function that derived classes may redefine.</li>
</ul>
</li>
<li><p>Item 39: Use private inheritance judiciously</p>
<ul>
<li><p>Clearly, private inheritance doesn’t mean is-a. What does it mean then?</p>
<ul>
<li><p>Private inheritance means is-implemented-in-terms-of.</p>
</li>
<li><p>If you make a class D privately inherit from a class B, you do so because you are interested in taking advantage of some of the features available in class B, not because there is any conceptual relationship between objects of types B and D. </p>
</li>
</ul>
</li>
<li><p>The fact that private inheritance means is-implemented-in-terms-of is a little disturbing, because Item 38 points out that composition can mean the same thing. How are you supposed to choose between them? The answer is simple: use composition whenever you can, and use private inheritance whenever you must. </p>
</li>
<li><p>If we were determined to use composition instead, we could.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Widget &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 		<span class="keyword">class</span> WidgetTimer: <span class="keyword">public</span> Timer &#123;</span><br><span class="line"> 		<span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">   		...</span><br><span class="line"> 		&#125;;</span><br><span class="line">  		WidgetTimer timer;</span><br><span class="line"> 		...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>there was an edge case involving space optimization that could nudge you to prefer private inheritance over composition.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Empty &#123;&#125;;            <span class="comment">// has no data, so objects should</span></span><br><span class="line">							<span class="comment">// use no memory</span></span><br><span class="line"><span class="keyword">class</span> HoldsAnInt &#123;         <span class="comment">// should need only space for an int</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 	<span class="keyword">int</span> x;</span><br><span class="line"> 	Empty e;           <span class="comment">// should require no memory</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>you’ll find that sizeof(HoldsAnInt) &gt; sizeof(int); an Empty data member requires memory. With most compilers, sizeof(Empty) is 1, because C++’s edict against zero-size freestanding objects is typically satisfied by the silent insertion of a char into “empty” objects. However, alignment requirements (see Item 50) may cause compilers to add padding to classes like HoldsAnInt, so it’s likely that HoldsAnInt objects wouldn’t gain just the size of a char, they would actually enlarge enough to hold a second int.</p>
</li>
<li><p>If you inherit from Empty instead of containing an object of that type,you’re almost sure to find that sizeof(HoldsAnInt) == sizeof(int). This is known as the empty base optimization (EBO).</p>
</li>
<li><p>Also worth knowing is that the EBO is generally viable only under single inheritance. The rules governing C++ object layout generally mean that the EBO can’t be applied to derived classes that have more than one base.</p>
</li>
</ul>
</li>
<li><p>Item 40: Use multiple inheritance judiciously</p>
<ul>
<li><p>One of the first things to recognize is that when MI enters the designscape, it becomes possible to inherit the same name (e.g., function, typedef, etc.) from more than one base class. That leads to new opportunities for ambiguity, even though only one of the these functions is accessible ( i.e. others are private). And to resolve the ambiguity, you must specify which base class’s function to call.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp<span class="class">.BorrowableItem</span><span class="value">::<span class="function">checkOut</span>();</span>    <span class="comment">// ah, that checkOut...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MI can also lead to what is sometimes known as the “deadly MI diamond”:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> InputFile: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> OutputFile: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> IOFile: <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>Any time you have an inheritance hierarchy with more than one path between a base class and a derived class, you must confront the question of whether you want the data members in the base class to be replicated for each of the paths. <strong>C++ takes no position on this debate. It happily supports both options, though its default is to perform the replication. </strong>If that’s not what you want, you must make the class with the data (i.e., File) a virtual base class. To do that, you have all classes that immediately inherit from it use virtual inheritance:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class File &#123; ... &#125;;</span><br><span class="line">class InputFile: &lt;b&gt;virtual&lt;/b&gt; public File &#123; ... &#125;;</span><br><span class="line">class OutputFile: &lt;b&gt;virtual&lt;/b&gt; public File &#123; ... &#125;;</span><br><span class="line">class IOFile: public InputFile, public OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Avoiding the replication of inherited fields requires some behind-the-scenes legerdemain on the part of compilers, and the result is that objects created from classes using virtual inheritance are generally larger than they would be without virtual inheritance. + slower access</p>
</li>
</ul>
</li>
<li><p>Item 41 - Item 48 all about Templates<br>=</p>
</li>
</ul>
<ul>
<li><p>Item 49: Understand the behavior of the new-handler</p>
<ul>
<li><p>When operator new is unable to fulfill a memory request, it calls the new-handler function repeatedly until it can find enough memory. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function to call if operator new can't allocate enough memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  std::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to satisfy request for memory\n"</span>;</span><br><span class="line">  std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  std::set_new_handler(outOfMem);</span><br><span class="line">  <span class="keyword">int</span> *pBigDataArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000L</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>this high-level description is enough to conclude that a well-designed new-handler function must do one of the following:</p>
<ul>
<li>Make more memory available.</li>
<li>Install a different new-handler.</li>
<li>Deinstall the new-handler.</li>
<li>Throw an exception.</li>
<li>Not return, typically by calling abort or exit.</li>
</ul>
</li>
<li><p>The C++ standardization committee didn’t want to abandon the test-for-null code base. So try following code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget *pw2 =<span class="keyword">new</span> (std::nothrow) Widget;   <span class="comment">// returns 0 if allocation for</span></span><br><span class="line">                                         <span class="comment">// the Widget fails</span></span><br><span class="line"><span class="keyword">if</span> (pw2 == <span class="number">0</span>) ...                    <span class="comment">// this test may succeed</span></span><br></pre></td></tr></table></figure>
<p>Although the operator new call in “new (std::nothrow) Widget” won’t throw, then, the Widget constructor might. So be careful.</p>
</li>
</ul>
</li>
<li><p>Item 50: Understand when it makes sense to replace new and delete</p>
<ul>
<li><p>These are three of the most common reasons that we want to replace the compiler-provided versions of operator new or operator delete:</p>
<ul>
<li>To detect usage errors.</li>
<li>To improve efficiency.<ul>
<li>To increase the speed of allocation and deallocation.</li>
<li>To reduce the space overhead of default memory management.</li>
<li>To cluster related objects near one another.(minimize frequency of page faults)</li>
<li>To compensate for suboptimal alignment in the default allocator.</li>
</ul>
</li>
<li>To obtain unconventional behavior, such as collecting usage statistics</li>
</ul>
</li>
<li><p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> signature = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Byte;</span><br><span class="line"><span class="comment">// this code has several flaws—see below</span></span><br><span class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::size_t size)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	size_t realSize = size + <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);    <span class="comment">// increase size of request so2</span></span><br><span class="line">                                              <span class="comment">// signatures will also fit inside</span></span><br><span class="line">	<span class="keyword">void</span> *pMem = <span class="built_in">malloc</span>(realSize);               <span class="comment">// call malloc to get theactual</span></span><br><span class="line">	<span class="keyword">if</span> (!pMem) <span class="keyword">throw</span> bad_alloc();                <span class="comment">// memory</span></span><br><span class="line">	<span class="comment">// write signature into first and last parts of the memory</span></span><br><span class="line">	*(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pMem)) = signature;</span><br><span class="line"> 	*(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem)+realSize-<span class="keyword">sizeof</span>(<span class="keyword">int</span>))) = signature;</span><br><span class="line">  	<span class="comment">// return a pointer to the memory just past the first signature</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>we’d probably return a pointer with improper alignment,(because of int signature).</p>
</li>
<li><p>Another option is open source memory managers.</p>
<ul>
<li>One such open source allocator is the Pool library from Boost (see Item 55).</li>
</ul>
</li>
</ul>
</li>
<li><p>Item 51: Adhere to convention when writing new and delete</p>
<ul>
<li>C++ requires that operator new return a legitimate pointer even when zero bytes are requested.        <pre><code class="C++"><span class="keyword">void</span> * <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::size_t size)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span>
</span>{                                      <span class="comment">// your operator new might</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;                 <span class="comment">// take additional params</span>
<span class="keyword">if</span> (size == <span class="number">0</span>) {                     <span class="comment">// handle 0-byte requests</span>
 size = <span class="number">1</span>;                          <span class="comment">// by treating them as</span>
}                                    <span class="comment">// 1-byte requests</span>
<span class="keyword">while</span> (<span class="keyword">true</span>) {
    attempt to allocate size bytes;
 <span class="keyword">if</span> (the allocation was successful)
    <span class="keyword">return</span> (a pointer to the memory);
 <span class="comment">// allocation was unsuccessful; find out what the</span>
 <span class="comment">// current new-handling function is (see below)</span>
 new_handler globalHandler = set_new_handler(<span class="number">0</span>);
 set_new_handler(globalHandler);
 <span class="keyword">if</span> (globalHandler) (*globalHandler)();
 <span class="keyword">else</span> <span class="keyword">throw</span> std::bad_alloc();
}
}
</code></pre>
</li>
<li>C++ guarantees it’s always safe to delete the null pointer.</li>
</ul>
</li>
<li><p>Item 52: Write placement delete if you write placement new</p>
<ul>
<li>to be continued….</li>
</ul>
</li>
</ul>

        
      </div>
    

    
      <div class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/tags/C-C/">
                #C/C++
              </a>
            
              <a href="/tags/tags/reading/">
                #reading
              </a>
            
          </div>
        

        
          <div class="post-nav">
            <div class="post-nav-prev post-nav-item">
              
                <a href="/tags/2014/10/15/2014-10-15-Report_Thread/">Report_Thread</a>
              
            </div>

            <div class="post-nav-next post-nav-item">
              
                <a href="/tags/2014/09/01/2014-09-01-interesting and boring/">var life == Interesting? Boring : Boring;</a>
              
            </div>
          </div>
        

        
        
      </div>
    
  </div>



  
    <div class="comments" id="comments">
      
        <div class="ds-thread" data-thread-key="2014/10/01/2014-10-01-Study Notes for <<Effective C++>>/"
             data-title="Reading Notes for Effective C++" data-url="http://runshenzhu.github.io/2014/10/01/2014-10-01-Study Notes for <<Effective C++>>/">
        </div>

      
    </div>
  

          </div>

          
        </div>

        
<div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>

<div id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
          Table Of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview">
          Overview
        </li>
      </ul>
    

    <div class="site-overview">
      <div class="site-author motion-element">
        <img class="site-author-image" src="http://hdn.xnimg.cn/photos/hdn421/20140526/0120/h_large_MbBi_27f5000176f81986.jpg" alt="Runshen.Zhu" />
        <p class="site-author-name">Runshen.Zhu</p>
      </div>
      <p class="site-description motion-element">excited!!!</p>
      <div class="site-state motion-element">
        <div class="site-state-item site-state-posts">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </div>
        <div class="site-state-item site-state-tags">
            <span class="site-state-item-count">13</span>
            <span class="site-state-item-name">tags</span>
        </div>
        <div class="site-state-item site-state-pages">
            <span class="site-state-item-count">2</span>
            <span class="site-state-item-name">pages</span>
        </div>
      </div>

      

      <div class="links-of-author motion-element">
        
          
            <span class="links-of-author-item">
              <a href="https://github.com/runshenzhu">GitHub</a>
            </span>
          
        
      </div>

      
      

    </div>

    
      <div class="post-toc-wrap sidebar-panel-active">
        <div class="post-toc-indicator-top post-toc-indicator"></div>
        <div class="post-toc">
          
          
            <p class="post-toc-empty">This post does not have a Table Of Contents</p>
          
        </div>
        <div class="post-toc-indicator-bottom post-toc-indicator"></div>
      </div>
    

  </div>
</div>


      </div>
    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Runshen.Zhu</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/tags/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/tags/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $(".fancybox").fancybox();
    });
  </script>

  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="/tags/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/tags/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  
  
<script type="text/javascript" id="bootstrap.scrollspy.custom">
  /* ========================================================================
  * Bootstrap: scrollspy.js v3.3.2
  * http://getbootstrap.com/javascript/#scrollspy
  * ========================================================================
  * Copyright 2011-2015 Twitter, Inc.
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  * ======================================================================== */

  /**
   * Custom by iissnan
   *
   * - Add a `clear.bs.scrollspy` event.
   * - Esacpe targets selector.
   */


  +function ($) {
    'use strict';

    // SCROLLSPY CLASS DEFINITION
    // ==========================

    function ScrollSpy(element, options) {
      this.$body          = $(document.body)
      this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
      this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
      this.selector       = (this.options.target || '') + ' .nav li > a'
      this.offsets        = []
      this.targets        = []
      this.activeTarget   = null
      this.scrollHeight   = 0

      this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
      this.refresh()
      this.process()
    }

    ScrollSpy.VERSION  = '3.3.2'

    ScrollSpy.DEFAULTS = {
      offset: 10
    }

    ScrollSpy.prototype.getScrollHeight = function () {
      return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }

    ScrollSpy.prototype.refresh = function () {
      var that          = this
      var offsetMethod  = 'offset'
      var offsetBase    = 0

      this.offsets      = []
      this.targets      = []
      this.scrollHeight = this.getScrollHeight()

      if (!$.isWindow(this.$scrollElement[0])) {
        offsetMethod = 'position'
        offsetBase   = this.$scrollElement.scrollTop()
      }

      this.$body
        .find(this.selector)
        .map(function () {
          var $el   = $(this)
          var href  = $el.data('target') || $el.attr('href')
          var $href = /^#./.test(href) && $(escapeSelector(href)) // Need to escape selector.

          return ($href
            && $href.length
            && $href.is(':visible')
            && [[$href[offsetMethod]().top + offsetBase, href]]) || null
        })
        .sort(function (a, b) { return a[0] - b[0] })
        .each(function () {
          that.offsets.push(this[0])
          that.targets.push(this[1])
        })


    }

    ScrollSpy.prototype.process = function () {
      var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
      var scrollHeight = this.getScrollHeight()
      var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
      var offsets      = this.offsets
      var targets      = this.targets
      var activeTarget = this.activeTarget
      var i

      if (this.scrollHeight != scrollHeight) {
        this.refresh()
      }

      if (scrollTop >= maxScroll) {
        return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
      }

      if (activeTarget && scrollTop < offsets[0]) {
        $(this.selector).trigger('clear.bs.scrollspy')  // Add a custom event.
        this.activeTarget = null
        return this.clear()
      }

      for (i = offsets.length; i--;) {
        activeTarget != targets[i]
          && scrollTop >= offsets[i]
          && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
          && this.activate(targets[i])
      }
    }

    ScrollSpy.prototype.activate = function (target) {
      this.activeTarget = target

      this.clear()

      var selector = this.selector +
        '[data-target="' + target + '"],' +
        this.selector + '[href="' + target + '"]'

      var active = $(selector)
        .parents('li')
        .addClass('active')

      if (active.parent('.dropdown-menu').length) {
        active = active
          .closest('li.dropdown')
          .addClass('active')
      }

      active.trigger('activate.bs.scrollspy')
    }

    ScrollSpy.prototype.clear = function () {
      $(this.selector)
        .parentsUntil(this.options.target, '.active')
        .removeClass('active')
    }


    // SCROLLSPY PLUGIN DEFINITION
    // ===========================

    function Plugin(option) {
      return this.each(function () {
        var $this   = $(this)
        var data    = $this.data('bs.scrollspy')
        var options = typeof option == 'object' && option

        if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
        if (typeof option == 'string') data[option]()
      })
    }

    var old = $.fn.scrollspy

    $.fn.scrollspy             = Plugin
    $.fn.scrollspy.Constructor = ScrollSpy


    // SCROLLSPY NO CONFLICT
    // =====================

    $.fn.scrollspy.noConflict = function () {
      $.fn.scrollspy = old
      return this
    }


    // SCROLLSPY DATA-API
    // ==================

    $(window).on('load.bs.scrollspy.data-api', function () {
      $('[data-spy="scroll"]').each(function () {
        var $spy = $(this)
        Plugin.call($spy, $spy.data())
      })
    })

  }(jQuery);
</script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0 && isDesktop()) {
        setTimeout(function () {
          $('.sidebar-toggle').trigger('click');
        }, 800);
      }
    });
  </script>




  

  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"runshenzhu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
  
</body>
</html>
